# СТРУКТУРА ПРОЕКТА
 - com/example/dicontainer /...
 - 						/App.java 		<- 	main() здесь
 - 						/service/
 - 								/impl/ 	<- реализации зависимости
 - 						/client/		<- клиентский код
 - 						/model/

# ЧАСТЬ 1, 
У нас есть класс, который отвечает за подготовку к празднования НГ.
	У него есть зависимость GiftPresenter, которая дарит подарки
	Чтоюбы пожарить подарок, его нужно
		Выбрать			\
		Оплатить		- тоже зависимости 
		Доставить		/
	
# После запуcка кода мы увидим:
*>Gift has been chosen: Smart watches
*>Pay 10000 for Smart watches by CARD
*>Deliver a Smart watches to Иван Иванов by POST	


Мы должны зависеть от абстракций, а не от реализаций (SOLID)
поэтому  GiftChooseHelper, PaymentSystem и DelivirySystem - это интерфейсы.

Раз есть абстракции, то должы быть реализации. У нас это 
	SmartGiftChooseHelper, 
	CardPaymentSystem, 
	PostDeliverySystem
Они реализовывают логику, которая прописана в контракте-интерейсе

Самый простой способ проинициализировать зависимости
 - это просто прописать их в сервисе GiftPresenter
В этом подходе ест даже 2 плюса:
	- простота- он реально простой
	- хорошо с точки зрения инкапсуляции, т.к. 
клиентский код ничего не знаетпро реализацию сервиса

На этом плюсы заканчиваются,и начинаются минусы:
	- если мы захотим изменить способ оплаты или доставки, нам придется изменять код GiftPresenter
Это нарушение SRP, и такой код очень поддерживать.
	- во время тестов GiftPresenter'а нельза за'mock'ать зависимости,
и во время тестирования они будут работать в штатном режиме (например, платить картой;)

*/

# ЧАСТЬ 2

Самый простой способ внедрить зависимость - сделать это через конструктор.
В классе GiftPresenter создадим корнструктор со всеми параметрами. 
Затем уберем из него все реализации, оставляя только абстракции. А реализации приходят через конрструктор.

Проблема теперь состоит только в том, что кто-то должен вызвать конструктор
 - и этот кто-то должен знать все наши зависимости.
то есть, наши реализации должен инициализировать клиенсткий код!
 